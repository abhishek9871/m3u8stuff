/**
 * Stream Extractor Service (Frontend)
 * 
 * Staged pipeline for extracting m3u8 streams from vidsrc.cc:
 * 
 * Pipeline:
 * 1. If debugHash provided (or window.__FLIXNEST_DEBUG_HASH), use it directly
 * 2. If VRF available (future), call getServers() then getSourceByHash()
 * 3. Fallback: return iframe embed URL for legacy playback
 * 
 * Based on Playwright research of real vidsrc.cc API chain.
 */

import type {
  StreamExtractionRequest,
  StreamExtractionResult,
  StreamSource,
  StreamDebugMetadata,
  ExtractedStream,
  VidsrcServer,
} from '../types/stream';

import { vidsrcApi, VIDSRC_STREAM_HEADERS } from './vidsrcApi';

// ============================================================
// RUNTIME EXTRACTION CONFIG
// ============================================================

/**
 * Configuration for external runtime hash extraction service.
 * 
 * The runtime is a separate Playwright-based service that:
 * 1. Opens vidsrc.cc embed page
 * 2. Waits for /api/{id}/servers request (with VRF generated by vidsrc.cc JS)
 * 3. Captures the response containing server hashes
 * 4. Returns the hashes to our frontend
 * 
 * This bypasses VRF by letting vidsrc.cc generate it naturally.
 */
// ============================================================
// BACKEND SCRAPER CONFIGURATION (PRIMARY METHOD)
// ============================================================

// Get backend scraper URL from environment
function getScraperUrl(): string {
  try {
    // @ts-ignore - Vite's import.meta.env
    const envUrl = import.meta.env?.VITE_SCRAPER_URL as string;
    if (envUrl) return envUrl;
  } catch { }

  // Default to localhost for development
  return 'https://abhishek1996-flixnest-scraper.hf.space/api/extract';
}

const SCRAPER_CONFIG = {
  // URL of the backend Playwright scraper
  get url(): string {
    return getScraperUrl();
  },

  // Timeout for scraper (ms) - longer because it launches browser
  timeout: 45000,

  // Enable debug logging
  debug: true,
};

// ============================================================
// PROXY CONFIGURATION (FALLBACK - kept for reference)
// ============================================================

// Get proxy worker URL from environment
function getProxyWorkerUrl(): string {
  try {
    // @ts-ignore - Vite's import.meta.env
    const envUrl = import.meta.env?.VITE_PROXY_WORKER_URL as string;
    if (envUrl) return envUrl;
  } catch { }

  // Default to localhost for development
  return 'http://localhost:8787';
}

const PROXY_CONFIG = {
  // URL of the Cloudflare Worker proxy
  get workerUrl(): string {
    return getProxyWorkerUrl();
  },

  // Timeout for proxy extraction (ms)
  timeout: 15000,

  // Enable debug logging
  debug: true,
};

// Get runtime service URL from environment (Vite injects this)
function getRuntimeServiceUrl(): string | null {
  try {
    // @ts-ignore - Vite's import.meta.env
    return (import.meta.env?.VITE_EXTRACTOR_SERVICE_URL as string) || null;
  } catch {
    return null;
  }
}

const RUNTIME_CONFIG = {
  // URL of the Playwright extraction service (to be deployed separately)
  // Example: 'https://flixnest-extractor.yoursite.workers.dev/extract'
  get serviceUrl(): string | null {
    return getRuntimeServiceUrl();
  },

  // Timeout for runtime extraction (ms)
  timeout: 30000,
};

// ============================================================
// GLOBAL DEBUG HASH (for manual testing)
// ============================================================

// Set this in browser console to test with a known hash:
// window.__FLIXNEST_DEBUG_HASH = "8gRy+i3edPAB...";
declare global {
  interface Window {
    __FLIXNEST_DEBUG_HASH?: string;
  }
}

// ============================================================
// STREAM EXTRACTOR CLASS
// ============================================================

/**
 * StreamExtractor - Staged pipeline for stream extraction
 */
export class StreamExtractor {
  private debugLogs: string[] = [];

  /**
   * Log a debug message
   */
  private log(message: string, data?: unknown): void {
    const logMessage = `[StreamExtractor] ${message}`;
    console.log(logMessage, data !== undefined ? data : '');
    this.debugLogs.push(`${message}${data ? ': ' + JSON.stringify(data) : ''}`);
  }

  /**
   * Get debug logs
   */
  getLogs(): string[] {
    return [...this.debugLogs];
  }

  /**
   * Clear debug logs
   */
  clearLogs(): void {
    this.debugLogs = [];
  }

  /**
   * Get debug hash from request or global window variable
   */
  private getDebugHash(request: StreamExtractionRequest): string | null {
    // Priority 1: Explicit debugHash in request
    if (request.debugHash) {
      return request.debugHash;
    }

    // Priority 2: Global window variable (for console testing)
    if (typeof window !== 'undefined' && window.__FLIXNEST_DEBUG_HASH) {
      return window.__FLIXNEST_DEBUG_HASH;
    }

    return null;
  }

  /**
   * Build iframe embed URL for fallback
   */
  private buildEmbedUrl(request: StreamExtractionRequest): string {
    const { type, tmdbId, season, episode } = request;
    let url = `https://vidsrc-embed.ru/embed/${type}/${tmdbId}`;

    if (type === 'tv' && season !== undefined && episode !== undefined) {
      url += `/${season}/${episode}`;
    }

    return url;
  }

  /**
   * Get server hashes from external runtime service.
   * 
   * This is the "Track A" approach: instead of reverse-engineering VRF,
   * we run a headless browser that lets vidsrc.cc generate VRF naturally,
   * then capture the /api/{id}/servers response.
   * 
   * The runtime service can be:
   * - A deployed Playwright script on a server
   * - A Cloudflare Durable Object with Browser Rendering
   * - A local development script
   * 
   * Expected API:
   * GET {RUNTIME_CONFIG.serviceUrl}?tmdbId=278&type=movie&season=1&episode=1
   * Response: { success: true, servers: [{ name: "VidPlay", hash: "..." }, ...] }
   * 
   * @throws Error if runtime is not configured or unavailable
   */
  private async getHashesFromRuntime(request: StreamExtractionRequest): Promise<VidsrcServer[]> {
    const { serviceUrl, timeout } = RUNTIME_CONFIG;

    // Check if runtime is configured
    if (!serviceUrl) {
      throw new Error('Runtime service URL not configured. Set VITE_EXTRACTOR_SERVICE_URL.');
    }

    const { type, tmdbId, season, episode } = request;

    // Build query params
    const params = new URLSearchParams({
      tmdbId,
      type,
    });

    if (type === 'tv' && season !== undefined && episode !== undefined) {
      params.set('season', String(season));
      params.set('episode', String(episode));
    }

    const url = `${serviceUrl}?${params.toString()}`;
    this.log('Calling runtime extraction service', { url });

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);

      const response = await fetch(url, {
        method: 'GET',
        headers: { 'Accept': 'application/json' },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`Runtime service returned HTTP ${response.status}`);
      }

      const data = await response.json();

      if (!data.success || !Array.isArray(data.servers)) {
        throw new Error(data.error || 'Invalid response from runtime service');
      }

      this.log('Runtime service returned servers', { count: data.servers.length });
      return data.servers as VidsrcServer[];

    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error(`Runtime service timed out after ${timeout}ms`);
      }
      throw error;
    }
  }

  /**
   * Convert ExtractedStream to StreamSource
   */
  private extractedStreamToSource(stream: ExtractedStream): StreamSource {
    return {
      url: stream.m3u8Url,
      quality: 'auto',
      provider: `vidsrc.cc/${stream.serverName}`,
      headers: stream.headers,
      isDefault: true,
      subtitles: stream.subtitles,
      serverName: stream.serverName,
    };
  }

  /**
   * Try backend Playwright scraper (PRIMARY METHOD)
   * 
   * This calls our backend service that runs Playwright to extract m3u8 URLs.
   * The backend runs a full browser, so origin restrictions don't apply.
   * 
   * Flow:
   * 1. Call GET /api/extract?tmdbId=X&type=movie
   * 2. Backend launches Playwright, navigates to vidsrc.cc
   * 3. Backend intercepts /api/source/{hash} response
   * 4. Backend returns m3u8 URL + subtitles
   * 5. We build ExtractedStream and return
   */
  private async tryBackendScraper(request: StreamExtractionRequest): Promise<StreamExtractionResult> {
    const scraperUrl = SCRAPER_CONFIG.url;
    const startTime = Date.now();

    try {
      const { type, tmdbId, season, episode } = request;

      // Build query params
      const params = new URLSearchParams({ tmdbId, type });

      if (type === 'tv' && season !== undefined && episode !== undefined) {
        params.set('season', String(season));
        params.set('episode', String(episode));
      }

      const url = `${scraperUrl}?${params.toString()}`;
      this.log('Calling backend scraper:', url);

      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), SCRAPER_CONFIG.timeout);

      const response = await fetch(url, {
        method: 'GET',
        headers: { 'Accept': 'application/json' },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: response.statusText }));
        this.log('Scraper returned error:', response.status, errorData);
        return {
          success: false,
          streams: [],
          error: {
            code: 'SCRAPER_ERROR',
            message: `Scraper error ${response.status}: ${errorData.error || response.statusText}`,
            step: 'backend-scraper',
          },
        };
      }

      const data = await response.json();

      if (!data.success || !data.m3u8Url) {
        this.log('Scraper returned no m3u8:', data);
        return {
          success: false,
          streams: [],
          error: {
            code: 'NO_M3U8_FOUND',
            message: data.error || 'Scraper found no m3u8 URL',
            step: 'backend-scraper',
          },
        };
      }

      this.log('Backend scraper extracted m3u8!', {
        url: data.m3u8Url.substring(0, 80),
        subtitles: data.subtitles?.length || 0,
        cached: data.cached,
        extractionTime: data.extractionTime
      });

      // Proxy the m3u8 URL through our backend to bypass CORS
      const scraperBaseUrl = SCRAPER_CONFIG.url.replace('/api/extract', '');
      const proxiedM3u8Url = `${scraperBaseUrl}/api/proxy/m3u8?url=${encodeURIComponent(data.m3u8Url)}`;

      this.log('Using proxied m3u8 URL:', proxiedM3u8Url.substring(0, 80));

      // Build ExtractedStream with proxied URL
      const extractedStream: ExtractedStream = {
        m3u8Url: proxiedM3u8Url,
        subtitles: data.subtitles || [],
        provider: 'vidsrc',
        serverName: data.serverName || 'scraper',
        // No headers needed - our proxy handles them
      };

      return {
        success: true,
        streams: [this.extractedStreamToSource(extractedStream)],
        extractedStream,
        debugMetadata: {
          provider: 'vidsrc.cc',
          timestamp: startTime,
          stepsCompleted: ['backend-scraper-success'],
          extractionTimeMs: Date.now() - startTime,
        },
      };

    } catch (error) {
      const isTimeout = error instanceof Error && error.name === 'AbortError';
      const errMsg = isTimeout
        ? `Scraper timed out after ${SCRAPER_CONFIG.timeout}ms`
        : (error instanceof Error ? error.message : 'Unknown error');

      this.log('Backend scraper error:', errMsg);

      return {
        success: false,
        streams: [],
        error: {
          code: isTimeout ? 'SCRAPER_TIMEOUT' : 'SCRAPER_EXCEPTION',
          message: errMsg,
          step: 'backend-scraper',
        },
        debugMetadata: {
          provider: 'vidsrc.cc',
          timestamp: startTime,
          stepsCompleted: ['backend-scraper-failed'],
          extractionTimeMs: Date.now() - startTime,
        },
      };
    }
  }

  /**
   * Build proxy URL for same-origin iframe
   */
  private buildProxyUrl(request: StreamExtractionRequest): string {
    const { type, tmdbId, season, episode } = request;
    const params = new URLSearchParams({ type, id: tmdbId });

    if (type === 'tv' && season !== undefined && episode !== undefined) {
      params.set('season', String(season));
      params.set('episode', String(episode));
    }

    return `${PROXY_CONFIG.workerUrl}/proxy?${params.toString()}`;
  }

  /**
   * Try same-origin proxy extraction
   * 
   * This creates a hidden iframe pointing to our Cloudflare Worker proxy.
   * The proxy serves vidsrc.cc content from our domain (same-origin).
   * Our injected interceptor script captures /api/source/{hash} responses
   * and sends the m3u8 URL via postMessage.
   * 
   * Flow:
   * 1. Create hidden iframe with proxy URL
   * 2. Worker proxies vidsrc.cc, injects interceptor
   * 3. vidsrc.cc JS runs, generates VRF naturally
   * 4. Interceptor captures m3u8 from /api/source/{hash}
   * 5. postMessage sends data to parent
   * 6. We receive it and return ExtractedStream
   */
  private trySameOriginProxy(request: StreamExtractionRequest): Promise<StreamExtractionResult> {
    return new Promise((resolve) => {
      this.log('Starting same-origin proxy extraction');

      const startTime = Date.now();
      let iframe: HTMLIFrameElement | null = null;
      let resolved = false;

      // Cleanup function
      const cleanup = () => {
        if (iframe && iframe.parentElement) {
          document.body.removeChild(iframe);
        }
        window.removeEventListener('message', messageHandler);
      };

      // Resolve helper (ensures single resolution)
      const resolveOnce = (result: StreamExtractionResult) => {
        if (resolved) return;
        resolved = true;
        cleanup();
        resolve(result);
      };

      // Message handler for postMessage from iframe
      const messageHandler = (event: MessageEvent) => {
        // Only handle messages from our proxy (or localhost for dev)
        const proxyOrigin = new URL(PROXY_CONFIG.workerUrl).origin;
        if (event.origin !== proxyOrigin && !event.origin.includes('localhost')) {
          return;
        }

        const { type, data } = event.data || {};

        if (type === 'FLIXNEST_INTERCEPTOR_READY') {
          this.log('Interceptor ready in iframe');
        }

        if (type === 'FLIXNEST_SERVERS_FOUND') {
          this.log('Servers found:', data?.count);
        }

        if (type === 'FLIXNEST_M3U8_CAPTURED' && data?.m3u8Url) {
          this.log('M3U8 captured via proxy!', {
            url: data.m3u8Url.substring(0, 80),
            subtitles: data.subtitles?.length || 0
          });

          const extractedStream: ExtractedStream = {
            m3u8Url: data.m3u8Url,
            subtitles: data.subtitles || [],
            provider: 'vidsrc',
            serverName: data.serverName || 'proxy',
            headers: data.headers || {
              Referer: 'https://vidsrc.cc/',
              Origin: 'https://vidsrc.cc',
            },
          };

          resolveOnce({
            success: true,
            streams: [this.extractedStreamToSource(extractedStream)],
            extractedStream,
            debugMetadata: {
              provider: 'vidsrc.cc',
              timestamp: startTime,
              stepsCompleted: ['proxy-extraction-success'],
              extractionTimeMs: Date.now() - startTime,
            },
          });
        }
      };

      // Listen for messages from iframe
      window.addEventListener('message', messageHandler);

      // Timeout handler
      const timeoutId = setTimeout(() => {
        this.log('Proxy extraction timeout');
        resolveOnce({
          success: false,
          streams: [],
          error: {
            code: 'PROXY_TIMEOUT',
            message: `Proxy extraction timed out after ${PROXY_CONFIG.timeout}ms`,
            step: 'proxy-extraction',
          },
          debugMetadata: {
            provider: 'vidsrc.cc',
            timestamp: startTime,
            stepsCompleted: ['proxy-timeout'],
            extractionTimeMs: Date.now() - startTime,
          },
        });
      }, PROXY_CONFIG.timeout);

      // Create hidden iframe
      const proxyUrl = this.buildProxyUrl(request);
      this.log('Loading proxy iframe:', proxyUrl);

      iframe = document.createElement('iframe');
      iframe.style.cssText = 'position:absolute;width:1px;height:1px;left:-9999px;opacity:0;pointer-events:none;';
      iframe.src = proxyUrl;
      // Allow scripts and same-origin access
      iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-forms');

      iframe.onload = () => {
        this.log('Proxy iframe loaded, waiting for m3u8 capture...');
      };

      iframe.onerror = () => {
        this.log('Proxy iframe failed to load');
        clearTimeout(timeoutId);
        resolveOnce({
          success: false,
          streams: [],
          error: {
            code: 'IFRAME_ERROR',
            message: 'Failed to load proxy iframe',
            step: 'proxy-extraction',
          },
        });
      };

      document.body.appendChild(iframe);
    });
  }

  /**
   * Main extraction method - staged pipeline
   */
  async extract(request: StreamExtractionRequest): Promise<StreamExtractionResult> {
    const startTime = Date.now();
    this.debugLogs = [];

    this.log('Starting extraction', request);

    const debugMetadata: StreamDebugMetadata = {
      provider: 'vidsrc.cc',
      timestamp: startTime,
      stepsCompleted: [],
    };

    try {
      // ========================================
      // STAGE 1: Check for debug hash (bypass servers API)
      // ========================================
      const debugHash = this.getDebugHash(request);

      if (debugHash) {
        this.log('Using debug hash (bypassing servers API)', { hashPreview: debugHash.substring(0, 30) + '...' });
        debugMetadata.stepsCompleted.push('1-debug-hash-detected');
        debugMetadata.usedDebugHash = true;

        const result = await vidsrcApi.getSourceByHash(debugHash, 'DebugServer');

        if (result.success && result.stream) {
          this.log('Debug hash extraction successful', { m3u8: result.stream.m3u8Url.substring(0, 80) });
          debugMetadata.stepsCompleted.push('2-source-extracted');

          const streamSource = this.extractedStreamToSource(result.stream);

          return {
            success: true,
            streams: [streamSource],
            extractedStream: result.stream,
            debugMetadata: {
              ...debugMetadata,
              extractionTimeMs: Date.now() - startTime,
            },
          };
        } else {
          this.log('Debug hash extraction failed', result.error);
          // Fall through to other stages
        }
      }

      // ========================================
      // STAGE 2: Backend Playwright Scraper (PRIMARY METHOD)
      // ========================================
      // This is the REAL working method:
      // 1. Call our backend scraper service
      // 2. Backend launches Playwright (full browser - no origin restrictions)
      // 3. Backend intercepts /api/source/{hash} response
      // 4. Returns m3u8 URL to frontend
      try {
        this.log('Stage 2: Attempting backend Playwright scraper...');
        debugMetadata.stepsCompleted.push('2-scraper-start');

        const scraperResult = await this.tryBackendScraper(request);

        if (scraperResult.success && scraperResult.extractedStream) {
          this.log('Backend scraper extraction successful!');
          debugMetadata.stepsCompleted.push('2-scraper-success');
          return {
            ...scraperResult,
            debugMetadata: {
              ...debugMetadata,
              ...scraperResult.debugMetadata,
            },
          };
        } else {
          this.log('Backend scraper failed', scraperResult.error);
          debugMetadata.stepsCompleted.push('2-scraper-failed');
        }
      } catch (scraperError) {
        this.log('Stage 2 error:', scraperError instanceof Error ? scraperError.message : 'Unknown');
        debugMetadata.stepsCompleted.push('2-scraper-error');
      }

      // ========================================
      // STAGE 3: Same-Origin Proxy Extraction (FALLBACK)
      // ========================================
      // Try the Cloudflare Worker proxy approach as a fallback
      try {
        this.log('Stage 3: Attempting same-origin proxy extraction...');
        debugMetadata.stepsCompleted.push('3-proxy-start');

        const proxyResult = await this.trySameOriginProxy(request);

        if (proxyResult.success && proxyResult.extractedStream) {
          this.log('Proxy extraction successful!');
          debugMetadata.stepsCompleted.push('3-proxy-success');
          return {
            ...proxyResult,
            debugMetadata: {
              ...debugMetadata,
              ...proxyResult.debugMetadata,
            },
          };
        } else {
          this.log('Proxy extraction failed', proxyResult.error);
          debugMetadata.stepsCompleted.push('3-proxy-failed');
        }
      } catch (proxyError) {
        this.log('Stage 3 error:', proxyError instanceof Error ? proxyError.message : 'Unknown');
        debugMetadata.stepsCompleted.push('3-proxy-error');
      }

      // ========================================
      // STAGE 4A: Runtime-assisted hash capture (LEGACY)
      // ========================================
      // Try to get hashes from external runtime (Playwright service, etc.)
      // This bypasses VRF by letting vidsrc.cc generate it naturally
      try {
        this.log('Stage 3A: Attempting runtime hash extraction...');
        const servers = await this.getHashesFromRuntime(request);

        if (servers.length > 0) {
          debugMetadata.stepsCompleted.push('3a-runtime-hashes-obtained');
          debugMetadata.serversFound = servers.length;

          // Try each server until one works
          for (const server of servers) {
            this.log(`Trying server: ${server.name}`, { hashPreview: server.hash.substring(0, 30) });
            const result = await vidsrcApi.getSourceByHash(server.hash, server.name);

            if (result.success && result.stream) {
              this.log('Runtime extraction successful', { server: server.name });
              debugMetadata.stepsCompleted.push('3a-source-extracted');

              return {
                success: true,
                streams: [this.extractedStreamToSource(result.stream)],
                extractedStream: result.stream,
                debugMetadata: {
                  ...debugMetadata,
                  extractionTimeMs: Date.now() - startTime,
                },
              };
            }
          }
        }
      } catch (runtimeError) {
        // Runtime not available - this is expected in most cases
        this.log('Stage 3A skipped: Runtime not available',
          runtimeError instanceof Error ? runtimeError.message : 'Unknown');
      }

      // ========================================
      // STAGE 3B: Direct VRF generation (TODO - FUTURE)
      // ========================================
      // TODO: When VRF generator is implemented:
      // 1. Call generateVrf({ tmdbId, type, imdbId, v })
      // 2. Call vidsrcApi.getServers(tmdbId, type, vrf)
      // 3. For each server, call vidsrcApi.getSourceByHash(hash)
      // 4. Return first successful stream
      //
      // For now, skip this stage since VRF deobfuscation is not complete
      this.log('Stage 3B skipped: VRF generator not yet implemented');
      debugMetadata.stepsCompleted.push('3b-vrf-skipped');

      // ========================================
      // STAGE 4: Fallback to iframe embed URL
      // ========================================
      this.log('Falling back to iframe embed URL');
      debugMetadata.stepsCompleted.push('4-fallback-iframe');

      const embedUrl = this.buildEmbedUrl(request);

      const fallbackStream: StreamSource = {
        url: embedUrl,
        quality: 'iframe',
        provider: 'vidsrc.cc/iframe',
        isDefault: true,
      };

      return {
        success: true,
        streams: [fallbackStream],
        debugMetadata: {
          ...debugMetadata,
          embedUrl,
          extractionTimeMs: Date.now() - startTime,
        },
      };

    } catch (error) {
      const errMsg = error instanceof Error ? error.message : 'Unknown error';
      this.log('Extraction failed with exception', errMsg);

      return {
        success: false,
        streams: [],
        error: {
          code: 'EXTRACTION_FAILED',
          message: errMsg,
          step: 'unknown',
        },
        debugMetadata: {
          ...debugMetadata,
          extractionTimeMs: Date.now() - startTime,
        },
      };
    }
  }

  /**
   * Extract stream using a known hash (convenience method for testing)
   */
  async extractWithHash(hash: string, serverName: string = 'ManualTest'): Promise<StreamExtractionResult> {
    this.log('extractWithHash() called', { hashPreview: hash.substring(0, 30), serverName });

    const result = await vidsrcApi.getSourceByHash(hash, serverName);

    if (result.success && result.stream) {
      return {
        success: true,
        streams: [this.extractedStreamToSource(result.stream)],
        extractedStream: result.stream,
        debugMetadata: {
          provider: 'vidsrc.cc',
          timestamp: Date.now(),
          stepsCompleted: ['direct-hash-extraction'],
          usedDebugHash: true,
        },
      };
    }

    return {
      success: false,
      streams: [],
      error: {
        code: 'HASH_EXTRACTION_FAILED',
        message: result.error || 'Failed to extract stream from hash',
        step: 'getSourceByHash',
      },
    };
  }
}

// ============================================================
// SINGLETON & EXPORTS
// ============================================================

// Singleton instance
export const streamExtractor = new StreamExtractor();

// Export convenience function
export async function extractStreams(request: StreamExtractionRequest): Promise<StreamExtractionResult> {
  return streamExtractor.extract(request);
}

// Export direct hash extraction for testing
export async function extractWithHash(hash: string, serverName?: string): Promise<StreamExtractionResult> {
  return streamExtractor.extractWithHash(hash, serverName);
}
